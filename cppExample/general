volatile: ask the compiler not to optimization for this variable
optimization (of some parts of your program) may be undesirable, because it may be that someone else is changing the value of some_int from outside the program which compiler is not aware of



int main()
{
    int a=5, b=0;
    int &r = a;
    r = b++;
    cout<<a<<r<<b;   //001

    return 0;
}

     struct A{
         ~A()
         {
             cout<< "~A";
         }
     };
     
     struct B: public A
     {
         virtual ~B()
         {
             cout<< "~B";
         }
     };
     
int main()
{


    A*a = new B();    // ~A
    delete a;
    return 0;
}

     struct A{
         virtual void print(int x = 1)
         {
             cout<< "A" << x;
         }
     };
     
     struct B: public A
     {
          virtual void print(int x = 2)
         {
             cout<< "B" << x;
         }
     };
     
int main()
{
    A*a = new B;
    a->print();
    return 0;
}

B1



The difference between vector and deque
One main difference between vectors and deques is that the latter allows efficient insertion at the front of the structure as well as the back.

Deques also do not guarantee that their elements are contiguous in memory so the at-style operator (indexing) may not be as efficient.

A deque is somewhat recursively defined: internally it maintains a double-ended queue of chunks (“blocks” in the graphic below) of fixed size. Each chunk is a vector, and the queue (“map” in the graphic below) of chunks itself is also a vector.


placement new
The simplest use is to place an object at a particular location in memory. This is done by supplying the place as a pointer parameter to the new part of a new expression
void someCode()
{
  char memory[sizeof(Fred)];     // Line #1
  void* place = memory;          // Line #2

  Fred* f = new(place) Fred();   // Line #3 (see "DANGER" below)
  // The pointers f and place will be equal

  ...
}

Order of Constructor/ Destructor Call in C++
 base class is called first to initialize all the inherited members.



lvalue, rvalue
An lvalue refers to an object that persists beyond a single expression. You can think of an lvalue as an object that has a name.
An rvalue is a temporary value that does not persist beyond the expression that uses it.
int x = 3 + 4;
In this example, x is an lvalue because it persists beyond the expression that defines it. The expression 3 + 4 is an rvalue because it evaluates to a temporary value that does not persist beyond the expression that defines it.

Unique pointer
A unique_ptr does not share its pointer. It cannot be copied to another unique_ptr, passed by value to a function, or used in any C++ Standard Library algorithm that requires copies to be made.
  std::unique_ptr<int> u3 (new int);

  The shared_ptr type is a smart pointer in the C++ standard library that is designed for scenarios in which more than one owner might have to manage the lifetime of the object in memory. After you initialize a shared_ptr you can copy it, pass it by value in function arguments, and assign it to other shared_ptr instances. All the instances point to the same object


Stack unwinding:
As you create objects statically (on the stack as opposed to allocating them in the heap memory) and perform function calls, they are "stacked up".

When a scope (anything delimited by { and }) is exited (by using return XXX;, reaching the end of the scope or throwing an exception) everything within that scope is destroyed (destructors are called for everything). This process of destroying local objects and calling destructors is called stack unwinding.

avoiding memory leaks (anything dynamically allocated that is not managed by a local object and cleaned up in the destructor will be leaked) 
the C++ specifications state that you should never throw an exception before any existing exception has been handled. This means that the stack unwinding process should never throw an exception


Exception safety guarantees, guidelines that class library implementers and clients can use when reasoning about exception handling safety in any programming language that uses exceptions, particularly C++.
no-leak guarantee



Memory management
static variable: 



The OFFSETOF() macro
#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT))

#include <stdio.h>
 
#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT))
 
typedef struct PodTag
{
   int     i;
   double  d;
   char    c;
} PodType;
 
int main()
{
   printf("%d", OFFSETOF(PodType, c) );
    
   getchar();
   return 0;
}

((size_t)&(((PodType *)0)->c))
Since we are considering 0 as address of the structure variable, c will be placed after 16 bytes of its base address i.e. 0x00 + 0x10. Applying & on the structure element (in this case it is c) returns the address of the element which is 0x10. Casting the address to unsigned int (size_t) results in number of bytes the element is placed in the structure.
